         МИНИСТЕРСТВО   ОБРАЗОВАНИЯ    УКРАИНЫ

   ХАРЬКОВСКИЙ  ГОСУДАРСТВЕННЫЙ  ТЕХНИЧЕСКИЙ  УНИВЕРСИТЕТ 
                     РАДИОЭЛЕКТРОНИКИ








                МЕТОДИЧЕСКИЕ  УКАЗАНИЯ
       К  САМОСТОЯТЕЛЬНОЙ  РАБОТЕ  СТУДЕНТОВ  ПО  КУРСУ
       "ИСКУССТВЕННЫЙ ИНТЕЛЛЕКТ И ЭКСПЕРТНЫЕ СИСТЕМЫ"
        ПО ИЗУЧЕНИЮ ПРОГРАММЫ, РЕАЛИЗУЮЩЕЙ МЕТОДЫ ПОИСКА





















                      ХАРЬКОВ  1999


         МИНИСТЕРСТВО   ОБРАЗОВАНИЯ    УКРАИНЫ

   ХАРЬКОВСКИЙ  ГОСУДАРСТВЕННЫЙ  ТЕХНИЧЕСКИЙ  УНИВЕРСИТЕТ 
                     РАДИОЭЛЕКТРОНИКИ







                МЕТОДИЧЕСКИЕ  УКАЗАНИЯ
       К  САМОСТОЯТЕЛЬНОЙ  РАБОТЕ  СТУДЕНТОВ  ПО  КУРСУ
      "ИСКУССТВЕННЫЙ  ИНТЕЛЛЕКТ  И  ЭКСПЕРНЫЕ  СИСТЕМЫ"
       ПО ИЗУЧЕНИЮ ПРОГРАММЫ, РЕАЛИЗУЮЩЕЙ МЕТОДЫ ПОИСКА


      для студентов специальностей 7.091401 "СИСТЕМЫ  
      УПРАВЛЕНИЯ И АВТОМАТИКА" и 7.080402 "ИНФОРМАЦИОННЫЕ
      ТЕХНОЛОГИИ ПРОЕКТИРОВАНИЯ"




                                     УТВЕРЖДЕНО
                                     кафедрой системотехники
                                     Протокол  N    от


     Составитель: М.Ю. Вишняк

     Ответственный за выпуск: Э.Г. Петров





                        ХАРЬКОВ 1999


     Методичнє вказєвки до самостiйних робєт студентiв з курсу
"Штучний iнтелект та експертнi системи" для студентєв спецєаль-
ностей 7.091401 - "Системи управлєння є автоматика", 7.080402 - 
"Iнформацiйнi технологiў проектування" /Упоряд: М.Ю. Вишняк. - 
Харкєв: ХТУРЕ, 1999. -   с.



                 Навчальне видання




     Упорядник: М.Ю. Вишняк



     Вєдповєдальний випусковий Е.Г. Петров
                      Редактор








План 1998, поз.

Пєдп. до друку             Формат 60х84          Папєр друк.
Умов. друк. арк.           Облєк вид. арк.       Тираж 100 прим.
Зам. N                     Цєна договєрна.
----------------------------------------------------------------
          ХТУРЕ, 310726 Харкєв, просп. Ленєна, 14
----------------------------------------------------------------
           Надруковано в учбово-виробничому
        видавнично-полєграфєчному центрє ХТУРЕ
           310726 Харкєв, просп. Ленєна, 14


      РЕШЕНИЕ ЗАДАЧ: ПРОЦЕДУРЫ ПОИСК РЕШЕНИЙ

                    Методы поиска

     Существует несколько методов поиска решения. Наиболее важные
и общие из них следующие:
  * поиск в глубину
  * поиск в ширину
  * поиск с подъемом на холм
  * поиск по наименьшей стоимости

          Выбор метода поиска

     Оценивание методов поиска может быть очень сложной процеду-
рой и, фактически, это составляло большую часть исследований в
области ИИ. Два наиболее важных вопроса, на которые следует об-
ратить внимание при оценивании, это:
1. Как быстро метод приводит к решению.
2. Насколько хорошо полученное решение.
     Существует ряд типов задач, в которых основная цель состоит
в нахождении любого допустимого решения с минимальными усилиями.
Для этих типов задач более важен первый критерий (вопрос). Одна-
ко, в других ситуациях, важным является то, что решение должно
быть наиболее близким к оптимальному.
     Длина пути к решению и фактическое число пройденных узлов
определяет скорость поиска. Помните, что возврат из тупиков - по
существу потраченное впустую усилие, поэтому желательно чтобы
возвратов было как можно меньше.
     Важно понять различие между нахождением оптимального реше-
ния и нахождением "хорошего" решения. Различие состоит в том, что
поиск оптимального решения часто влечет за собой исчерпывающий 
поиск (полный перебор), потому что часто это может быть единст-
венным способом определения того, было ли найдено оптимальное 
решение. Однако, получение хорошего решения означает нахождение 
такого, которое только удовлетворяет заданному набору ограниче-
ний - независимо от того, существует или нет более лучшее реше-
ние, то есть поиск любого решения из допустимой облати или выбор
решения из нескольких допустимых решений.
     Каждый из методов поиска будет работать в каких-то опреде-
ленных ситуациях лучше, чем другие. К тому же, трудно сказать, 
будет ли один метод поиска всегда превосходить другой.  Однако,
некоторые методы поиска будут иметь большую вероятность оказать-
ся более эффективными для некоторого среднего случая. Также, са-
мо описание задачи будет иногда помогать Вам выбрать соответст-
вующий метод поиска.

          Постановка задачи-примера

     Представьте, что клиент хочет заказать билет на рейс от 
Нью-Йорка до Лос-Анджелеса на самолет авиакомпании "XYZ Авиали-
нии", причем у авиакомпании "XYZ" нет прямого рейса от Нью-Йорка
до Лос-Анджелеса. Клиент настаивает на полете самолетом только 
компании "XYZ". Глядя на список рейсов авиакомпании "XYZ"

    Из Нью-Йорка в Чикаго      1000 миль
    Из Чикаго в Денвер         1000 миль
    Из Нью-Йорка в Торонто      800 миль
    Из Нью-Йорка в Денвер      1900 миль
    Из Торонто в Калгари       1500 миль
    Из Торонто в Лос-Анджелес  1800 миль
    Из Торонто в Чикаго         500 миль
    Из Денвера в Урбану        1000 миль
    Из Денвера в Хьюстон       1500 миль
    Из Хьюстона в Лос-Анджелес 1500 миль
    Из Денвера в Лос-Анджелес  1000 миль

можно сразу видеть, что имеется путь от Нью-Йорка до Лос-Андже-
леса на самолете "XYZ", с использованием связанных рейсов. В ре-
зультате клиенту можно предоставить билет.
     Задача состоит в том, чтобы написать программы на языке С,
которые выполняют ту же самую процедуру и даже лучшим способом.

          Графическое представление

     Список рейсов компании "XYZ" может быть преобразован в на-
правленный граф, показанный на рис. 11.3. Стрелки указывают на-
правление движения. В направленном графе невозможно двигаться в
направлении против стрелки.
     Информация о рейсах будет легче восприниматься, если преоб-
разовать граф в дерево, как показано на рис. 11.4. Здесь цель,
Лос-Анджелес, обведена кружком; различные города появляются в 
дереве более чем один раз, чтобы упростить его построение.

  << Рисунок 11.4 Версия таблицы рейсов в виде дерева.>>

                 Поиск в глубину

     Поиск вглубину исследует каждый возможный путь до самого 
конца прежде, чем перейдет к другому пути, если цель не была об-
наружена. Чтобы понять как работает этот метод, рассмотрим дере-
во, в котором F является целью:
   <<рисунок>>
     Поиск вглубину пройдет через узлы графа в последовательнос-
ти ABDBEBACF. При этом типе поиска первоначально в каждой прохо-
дящей вершине выбирается крайняя левая дуга. Продвижение осуще-
ствляется до тех пор, пока не достигается или терминальный узел
или цель. Если встретился терминальный узел, то необходимо вер-
нуться на один уровень назад и свернуть направо, а затем продол-
жать держаться левой стороны, пока не встречается или  цель или
новый терминальный узел. Если для какого-то промежуточного узла
все исходящие дуги исследованы и они ведут в тупик, то осуществ-
ляется возврат к предыдущему узлу. Этот процесс повторяется до
тех пор, пока не находится цель или не будут пройдены все узлы 
из области поиска. Поиск вглубину гарантированно находит цель
(если она существует), потому что в самом худшем случае он пере-
ходит в полный перебор, который имел бы место, если бы вершина G 
была целью.
     Программа, определяющая маршрут от Нью-Йорка до Лос-Андже-
леса, требует использование базы данных, которая содержит инфор-
мацию о рейсах компании "XYZ". Записи в базе данных будут содер-
жать наименование пункта вылета и пункта назначения, расстояние
между ними, и флаг, который необходим в процедуре возврата. Вот
структура записи базы данных:

  #define MAX 100
  /* structure of the flight database(db) */
     struct FL {
       char from[20];
       char to[20];
       int distance;
       char skip;           /* used in backtracking */
     };
     struct FL flight[MAX]; /* array of db structures */
     int f_pos=0;           /* number of entries in flight db */
     int find_pos=0;        /* index for searching flight db */

Записи помещаются в базу данных flight функцией assert_flight(),
функция setup() инициализирует базу. Глобальная переменная f_pos
является индексом последнего элемента базы данных. База данных
содержит факты, которые программа использует для достижения цели,
т.е. нахождения решения. 
     Программа поиска маршрута между Нью-Йорком и Лос-Анджелесом
нуждается в нескольких функциях поддержки. Во-первых, необходима
процедура, которая может определять, есть ли рейс между двумя 
городами. Эта функция называется match(); она возвращает 0, если
такого рейса не существует, или расстояние между двумя городами,
если рейс есть. Вторая необходимая процедура - find(). Она ищет
в базе данных смежные рейсы для заданного названия города. Если
find() находит смежный рейс, то она возвращает название города
назначения и расстояние;  если она не находит, то возвращает 0.
Если find() находит смежный рейс, она отмечает эту связь, пере-
водя поле skip в активное состояние (записывается 1). Этот шаг
используется, чтобы управлять возвратом из тупиков.
     Процедура возврата является важной составляющей многих ме-
тодов ИИ. Ее можно выполнять, используя рекурсивную процедуру и
стек возврата. Фактически, все cтекосодержащие операции с возв-
ратом выполняются по схеме LIFO. Таким образом, при прохождении
пути каждый встречающийся узел помещается в стек. В каждом тупи-
ке процедура поиска удаляет последний узел из стека и пробует
новый путь, начиная от этого пункта. Процесс поиска продолжается,
до тех пор пока не достигается цель или исчерпываются все возмож-
ные пути. Функции работы со стеком push() и pop() используют гло-
бальные переменные tos и bt_stack. Переменная tos содержит номер
последнего элемента стека (указывает на вершину стека), а 
bt_stack - имя массива, являющегося стеком.
     Процедура isflight() определяет маршрут между двумя города-
ми. Функция isflight() работает следующим образом. Первоначаль-
но, match() просматривает базу данных, на предмет того, есть ли
рейс между пунктами from и to. Если такой рейс существует, то
узел помещается в стек и выход из функции. Если рейса нет, то 
find() проверяет, существует ли рейс между пунктом from и каким-
либо другим городом (anywhere). Если рейс есть, то процедура по-
мещает искомую связь from to в стек и рекурсивно вызывает функ-
цию isflight() для определения маршрута между пунктами anywhere
и to. Если из пункта from нет никакого рейса, то происходит воз-
врат: удаляется предыдущий узел из стека и рекурсивно вызывается
isflight(). Этот процесс продолжается до тех пор, пока процедура
не находит цель. Поле skip используется в процедуре возврата для 
предотвращения попытки многократной проверки одних и тех же свя-
зей. Если требуется найти маршрут из Денвера в Хьюстон, то пер-
вая часть функции isflight() выполняется и поиск на этом закан-
чивается. Однако, если isflight() вызывается для Чикаго и Хьюс-
тона, то первая часть пропускается, потому что нет прямого рейса
между этими двумя городами. Затем во второй части функции дела-
ется попытка найти рейс между исходным городом и любым другим.
В данном случае есть рейс между Чикаго и Денвером, поэтому про-
цедура isflight() рекурсивно вызывается с параметрами "Денвер" 
и "Хьюстон". Функция isflight() снова проверяет первое условие,
но на этот раз она находит связь. Рекурсивный вызов заканчивает-
ся и isflight() завершает работу.
     Важно понять, что flight() фактически не возвращают решение,
а вырабатывает его. Ключевым пунктом является то, что при выходе
из isflight(), стек возврата содержит маршрут между исходными 
городами. Состояние стека показывает успех или неудачу  работы
isflight(). Если маршрут найден, то стек содержит решение; пус-
той стек указывает на отсутствие решения. Таким образом, заклю-
чительная функция route() выводит полученный путь и полное рас-
стояние.
     Функция main() запрашивает название начального города и
конечного. Это позволяет использовать программу для нахождения
маршруты между любыми двумя городами. Однако, последующие про-
граммы предполагают, что Нью-Йорк - исходный пункт, а Лос-Анд-
желес - конечный.
     Запустите программу на исполнение. Должен быть получен
следующий результат :

  New York to Chicago to Denver to Los Angeles
  distance is 3000

 << Рисунок 11.5. Полученный путь для поиска по глубине.>>

     Если рассмотреть рис.11.4, то видно, что это действительно
первое решение, которое можно найти, используя поиск вглубину. В
то же время оптимальное решение выглядит так: из Нью-Йорка в То-
ронто в Лос-Анджелес с расстоянием 2600 миль. Но полученное ре-
шение не такое уж плохое. 
     В рассмотренном примере поиском вглубину было найдено до-
вольно хорошее решение при первой же попытке и без какого-либо
возврата, причем очень хорошее решение. Однако, для достижения
оптимального решения необходимо было бы пройти почти все узлы,
что не так уж хорошо. Поиск вглубину может весьма слабо работать
в тех ситуациях, когда необходимо исследовать особо сложную зада-
чу, не имеющую решения. В этом случае, поиск вглубину будет тра-
тить впустую значительное время.

#define MAX 100
 /* структура базы данных рейсов */
struct FL 
  { char  from[20];
    char  to [20];
     int  distance;
    char  skip;  /* used in backtracking  */
  };
struct stack
  { char  from[20];
    char  to[20];
     int  dist;
};

/* Depth-first search                     19.11.98
*/
#include <conio.h>
#include <stdio.h>
#include "search.h"

void isflight (char *, char *);
void route (char *);
void setup (void);

struct FL flight[MAX]; /* array of db structures */
int f_pos=0;           /* number of entries in flight db */
int find_pos=0;        /* index for searching flight db */
int tos=0;             /* top of stack */
struct stack bt_stack[MAX]; /* backtracking stack */

void main()
{
   char from[20],to[20];

   setup();
   printf ("from? ");
   gets (from);
   printf("to? ");
   gets (to);
   isflight (from, to);
   route (to);
   getch();
   return;
}
 /* place facts into flight db        19.11.98
*/
#include <stdio.h>
#include "search.h"

 void assert_flight (from, to, dist)
	       char  *from, *to;
		int  dist;
{
       extern int  f_pos;
 extern struct FL  flight[];

  if (f_pos < MAX)
  { 
     strcpy (flight[f_pos].from, from);
     strcpy (flight[f_pos].to, to);
     flight[f_pos].distance = dist;
     flight[f_pos].skip = 0;
     f_pos++;
  }
  else printf("Flight database full.\n");
  return;
}
/* given from, find anywhere          16.11.98
*/
#include <string.h>
#include "search.h"

int find (from, anywhere)
    char *from, *anywhere;
{
extern struct FL  flight[];
      extern int  find_pos, f_pos;

   find_pos=0;
   while (find_pos < f_pos)
     {
      if (!strcmp (flight[find_pos].from,from) &&
	  !flight[find_pos].skip)
        {
	  strcpy (anywhere, flight[find_pos].to);
	  flight[find_pos].skip = 1;  /* make active */
	  return  flight[find_pos].distance;
        }
      find_pos++;
   }
   return 0;
}
/* determine if there is a route          19.11.98
   between from and to */

void isflight (from,to)
    char *from,*to;
{
       int  d,dist;
      char  anywhere[20];
extern int  tos;

  /* see if destination is reached */
  d= match(from,to);
  if (d)
   {
     push (from, to ,d);
     return;
   }
  /* try another connection */
  dist = find(from,anywhere);
  if (dist)
    {
     push (from,to,dist);
     isflight (anywhere,to);
    }
    else 
      if (tos > 0)
       { /*backtrack*/
         pop (from,to,&dist);
         isflight (from,to);
       }
  return;
}
/* if connection between from and to,          16.11.98
   then return the distance of flight; 
   if not, return 0 */
#include <string.h>
#include "search.h"

 int match (from,to)
     char *from, *to;
{
    register int  t;
extern struct FL  flight[];
      extern int  f_pos;

  for (t=f_pos-1; t>-1; t--)
    if(!strcmp(flight[t].from,from)&&
       !strcmp(flight[t].to,to))  return flight[t].distance;
  return 0; /* not found */
}
/*                                   19.11.98
*/
#include <stdio.h>
#include <string.h>
#include "search.h"

void pop (from,to,dist)
    char  *from, *to;
     int  *dist;
{
	 extern int  tos;
extern struct stack  bt_stack[];

  if(tos > 0)
    {
      tos--;
      strcpy(from,bt_stack[tos].from);
      strcpy(to,bt_stack[tos].to);
      *dist=bt_stack[tos].dist;
    }
   else printf("Stack underflow.\n");
}
/* stack routness                19.11.98
*/
#include <string.h>
#include <stdio.h>
#include "search.h"

void push (from,to,dist)
      char  *from, *to;
       int  dist;
{
extern struct stack  bt_stack[];
extern int  tos;

   if (tos < MAX)
   {
     strcpy(bt_stack[tos].from,from);
     strcpy(bt_stack[tos].to,to);
     bt_stack[tos].dist=dist;
     tos++;
   }
    else  printf("Stack full.\n");
   return;
}

/*  found the route and distance             19.11.98
*/
#include <stdio.h>
#include "search.h"

void route (to)
    char *to;
{
                int  dist,t;
extern struct stack  bt_stack[];
         extern int  tos;

  t=0;
  dist=0;
  while (t<tos)  
    {
      printf("%s to ", bt_stack[t].from);
      dist += bt_stack[t].dist;
      t++;
    }
  printf("%s\n",to);
  printf("distance is %d\n",dist);
  return;
}
void setup()
{
  assert_flight("New York","Chicago",1000);
  assert_flight("Chicago","Denver",1000);
  assert_flight("New York","Toronto",800);
  assert_flight("New York","Denver",1900);
  assert_flight("Toronto","Calgary",1500);
  assert_flight("Toronto","Los Angeles",1800);
  assert_flight("Toronto","Chicago",500);
  assert_flight("Denver","Urbana",1000);
  assert_flight("Denver","Houston",1500);
  assert_flight("Houston","Los Angeles",1500);
  assert_flight("Denver","Los Angeles",1000);

  assert_flight("С.-Петербург","Москва",640);
  assert_flight("С.-Петербург","Рига",480);
  assert_flight("Рига","Минск",410);
  assert_flight("Москва","Минск",660);
  assert_flight("Москва","Харьков", 650);
  assert_flight("Минск","Харьков",740);
  assert_flight("Минск","Киев",440);
  assert_flight("Москва","Киев",740);
  assert_flight("Киев","Харьков",410);
  assert_flight("Киев","Львов",470);
  assert_flight("Киев","Одесса",450);
  assert_flight("Львов","Одесса",620);
  assert_flight("Киев","Симферополь",660);
  assert_flight("Киев","Днепропетровск",390);
  assert_flight("Харьков","Одесса",560);
  assert_flight("Харьков","Симферополь",580);
  assert_flight("Харьков","Донецк",250);
  assert_flight("Донецк","Симферополь",440);
  assert_flight("Днепропетровск","Симферополь",400);
  assert_flight("Одесса","Симферополь",320);
  assert_flight("Симферополь","Одесса",320);
  return;
  }
=====================================================================


                Метод поиска в ширину

     Метод поиска в ширину является противоположностью поиска
вглубину. Поиск в ширину проверяет каждый узел на том же самом
уровне прежде, чем он переходит к следующему уровню.
        <<Рисунок>> (C является целью)
     Рисунок показывает, что проход осуществляется через узлы
ABC. Подобно поиску вглубину, поиск в ширину гарантирует обнару-
жение решения, если оно существует, потому что поиск в конечном
счете вырождается в полный перебор.
     В предыдущей программе, чтобы она выполняла поиск в ширину,
требуется только изменить функцию isflight (). Изменение касает-
ся только первого условия. Теперь, программа проверяет все горо-
да, которые соединяются с городом отправления, чтобы увидеть,
соединяются ли они с городом предназначения. Новая версия про-
граммы дает следующее решение:

   New York to Toronto to Los Angeles
   distance is 2600

   Оно является  оптимальным  решением. На рисунке  11.6 показан
путь, по которому происходит движение в соответствии с поиском в
ширину.
     Для данного примера поиск в ширину работает хорошо, без воз-
вратов. Как оказалось, полученное решение является также опти-
мальным. Фактически, первые три решения, которые могут быть най-
дены, являются лучшими тремя маршрутами! Однако, нельзя обобщать
этот результат на другие ситуации, потому что результат зависит
от организации информации, записаной в компьютере. Однако, этот
результат иллюстрирует радикальное различие поисков вглубину и в
ширину. Недостатки поиска в ширину проявляются, когда осуществ-
ляется попытка нахождения цели, расположенной на несколько уров-
ней глубже. В этом случае, поиск в ширину прилагает существенное
усилие, чтобы найти решение. Вообще, программист выбирает между
поиском вглубину и поиском в ширину, делая предположение относи-
тельно того, где наиболее вероятно положение цели.

  << Рисунок 11.6 Путь продвижения поиска по широте к решению.>>


#define MAX 100
 /* структура базы данных рейсов */
struct FL 
  { char  from[20];
    char  to [20];
     int  distance;
    char  skip;  /* used in backtracking  */
  };
struct stack
  { char  from[20];
    char  to[20];
     int  dist;
};

 /* Breadth-first search                     19.11.98
*/
#include <conio.h>
#include <stdio.h>
#include "search.h"

void isflight (char *, char *);
void route (char *);
void setup (void);

struct FL flight[MAX]; /* array of db structures */
int f_pos=0;           /* number of entries in flight db */
int find_pos=0;        /* index for searching flight db */
int tos=0;             /* top of stack */
struct stack bt_stack[MAX]; /* backtracking stack */

void main()
{
   char from[20],to[20];

   setup();
   printf ("from? ");
   gets (from);
   printf("to? ");
   gets (to);
   isflight (from, to);
   route (to);
   getch();
   return;
}
/* place facts into flight db        19.11.98
*/
#include <stdio.h>
#include <string.h>
#include "search.h"

 void assert_flight (from, to, dist)
	       char  *from, *to;
		int  dist;
{
       extern int  f_pos;
 extern struct FL  flight[];

  if (f_pos < MAX)
  {
     strcpy (flight[f_pos].from, from);
     strcpy (flight[f_pos].to, to);
     flight[f_pos].distance = dist;
     flight[f_pos].skip = 0;
     f_pos++;
  }
  else printf("Flight database full.\n");
  return;
}
/* given from, find anywhere          16.11.98
*/
#include <string.h>
#include "search.h"

int find (from, anywhere)
    char *from, *anywhere;
{
extern struct FL  flight[];
      extern int  find_pos, f_pos;

   find_pos=0;
   while (find_pos < f_pos)
     {
      if (!strcmp (flight[find_pos].from,from) &&
	  !flight[find_pos].skip)
        {
	  strcpy (anywhere, flight[find_pos].to);
	  flight[find_pos].skip = 1;  /* make active */
	  return  flight[find_pos].distance;
        }
      find_pos++;
   }
   return 0;
}
/* determine if there is a route          19.11.98
   between from and to       "breadth-first mth"    */

void isflight (from,to)
    char *from,*to;
{
       int  d,dist;
      char  anywhere[20];
extern int  tos;

while (dist = find (from, anywhere))
  {
    d = match (anywhere,to);
    if (d)
      {
	push (from, to ,dist);
	push (anywhere,to,d);
	return;
      }
  }
  /* try any connection */
  dist = find(from,anywhere);
  if (dist)
    {
     push (from,to,dist);
     isflight (anywhere,to);
    }
    else 
      if (tos > 0)
       { /*backtrack*/
         pop (from,to,&dist);
         isflight (from,to);
       }
  return;
}
/* if connection between from and to,          16.11.98
   then return the distance of flight; 
   if not, return 0 */
#include <string.h>
#include "search.h"

 int match (from,to)
     char *from, *to;
{
    register int  t;
extern struct FL  flight[];
      extern int  f_pos;

  for (t=f_pos-1; t>-1; t--)
    if(!strcmp(flight[t].from,from)&&
       !strcmp(flight[t].to,to))  return flight[t].distance;
  return 0; /* not found */
}
/*                                   19.11.98
*/
#include <stdio.h>
#include <string.h>
#include "search.h"

void pop (from,to,dist)
    char  *from, *to;
     int  *dist;
{
	 extern int  tos;
extern struct stack  bt_stack[];

  if(tos > 0)
    {
      tos--;
      strcpy(from,bt_stack[tos].from);
      strcpy(to,bt_stack[tos].to);
      *dist=bt_stack[tos].dist;
    }
   else printf("Stack underflow.\n");
}
/* stack routness                19.11.98
*/
#include <string.h>
#include <stdio.h>
#include "search.h"

void push (from,to,dist)
      char  *from, *to;
       int  dist;
{
extern struct stack  bt_stack[];
extern int  tos;

   if (tos < MAX)
   {
     strcpy(bt_stack[tos].from,from);
     strcpy(bt_stack[tos].to,to);
     bt_stack[tos].dist=dist;
     tos++;
   }
    else  printf("Stack full.\n");
   return;
}

/*  found the route and distance             19.11.98
*/
#include <stdio.h>
#include "search.h"

void route (to)
    char *to;
{
                int  dist,t;
extern struct stack  bt_stack[];
         extern int  tos;

  t=0;
  dist=0;
  while (t<tos)  
    {
      printf("%s to ", bt_stack[t].from);
      dist += bt_stack[t].dist;
      t++;
    }
  printf("%s\n",to);
  printf("distance is %d\n",dist);
  return;
}
