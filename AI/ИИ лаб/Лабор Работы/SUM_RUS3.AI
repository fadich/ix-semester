         МИНИСТЕРСТВО   ОБРАЗОВАНИЯ    УКРАИНЫ

   ХАРЬКОВСКИЙ  ГОСУДАРСТВЕННЫЙ  ТЕХНИЧЕСКИЙ  УНИВЕРСИТЕТ 
                     РАДИОЭЛЕКТРОНИКИ








                МЕТОДИЧЕСКИЕ  УКАЗАНИЯ
       К  САМОСТОЯТЕЛЬНОЙ  РАБОТЕ  СТУДЕНТОВ  ПО  КУРСУ
       "ИСКУССТВЕННЫЙ ИНТЕЛЛЕКТ И ЭКСПЕРТНЫЕ СИСТЕМЫ"
        ПО ИЗУЧЕНИЮ ПРОГРАММЫ РАСПОЗНАВАНИЯ ОБРАЗОВ





















                      ХАРЬКОВ  1999


         МИНИСТЕРСТВО   ОБРАЗОВАНИЯ    УКРАИНЫ

   ХАРЬКОВСКИЙ  ГОСУДАРСТВЕННЫЙ  ТЕХНИЧЕСКИЙ  УНИВЕРСИТЕТ 
                     РАДИОЭЛЕКТРОНИКИ







                МЕТОДИЧЕСКИЕ  УКАЗАНИЯ
       К  САМОСТОЯТЕЛЬНОЙ  РАБОТЕ  СТУДЕНТОВ  ПО  КУРСУ
      "ИСКУССТВЕННЫЙ  ИНТЕЛЛЕКТ  И  ЭКСПЕРНЫЕ  СИСТЕМЫ"
       ПО ИЗУЧЕНИЮ ПРОГРАММЫ РАСПОЗНАВАНИЯ ОБРАЗОВ


      для студентов специальностей 7.091401 "СИСТЕМЫ  
      УПРАВЛЕНИЯ И АВТОМАТИКА" и 7.080402 "ИНФОРМАЦИОННЫЕ
      ТЕХНОЛОГИИ ПРОЕКТИРОВАНИЯ"




                                     УТВЕРЖДЕНО
                                     кафедрой системотехники
                                     Протокол  N    от

     Составитель: М.Ю. Вишняк


     Ответственный за выпуск: Э.Г. Петров





                        ХАРЬКОВ 1999


     Методичнє вказєвки до самостiйних робєт студентiв з курсу
"Штучний iнтелект та експертнi системи" для студентєв спецєаль-
ностей 7.091401 - "Системи управлєння є автоматика", 7.080402 - 
"Iнформацiйнi технологiў проектування" /Упоряд: М.Ю. Вишняк. - 
Харкєв: ХТУРЕ, 1999. -   с.



                 Навчальне видання




     Упорядник: М.Ю. Вишняк



     Вєдповєдальний випусковий Е.Г. Петров
                      Редактор








План 1998, поз.

Пєдп. до друку             Формат 60х84          Папєр друк.
Умов. друк. арк.           Облєк вид. арк.       Тираж 100 прим.
Зам. N                     Цєна договєрна.
----------------------------------------------------------------
          ХТУРЕ, 310726 Харкєв, просп. Ленєна, 14
----------------------------------------------------------------
           Надруковано в учбово-виробничому
        видавнично-полєграфєчному центрє ХТУРЕ
           310726 Харкєв, просп. Ленєна, 14

       ТЕХНИЧЕСКОЕ ЗРЕНИЕ И РАСПОЗНАВАНИЕ ОБРАЗОВ

      Распознавание двумерного образа

    Из-за сложности трехмерных изображений и методов, которые 
позволяют распознать их, здесь ограничемся двухмерными высоко- 
контрастными плоскими изображения. Этот тип изображения будет 
использоваться в примерах. (Можно применять некоторых из ме-
тодов, обсуждаемых здесь, к более сложному миру трехмернного 
распознавания образов.)
     Существует множество способов, которыми компьютер может 
распознавать объекты. Некоторые из них в определенных ситуациях 
работают лучше, чем другие. Некоторые методы работают только со 
специфическими объектами, в то время как другие могут работать 
с объектами более общего класса. Следовательно, трудно разрабо-
тать объективный набор критериев, который определял бы, является 
ли один подход лучше другого. Однако, ответы на следующие вопро-
сы помогут Вам понять в какой ситуации можно применять конкрет-
ный метод распознавания и каковы его ограничения.
1. Позволяет ли метод правильно распознавать объекты, перекрыва-
   емые другими объектами или помещенные один сверху другого?
2. Влияет ли ориентация объекта на результат его распознавания? 
3. Влияют ли конкретные размеры объекта на результат его распо-
   знавания?
4. Насколько эффективен метод?
5. Может ли метод заблуждаться и допускает ли ошибки?

В русле этих вопров рассмотрим три отдельные метода распознава-
ния изображений.

     1. Ситуация

     Программы распознавания образов должны правильно идентифи-
цировать треугольники и квадраты. Сначала, будет распознаваться 
только один тип треугольника - равнобедренный. Затем, добавля-
ется правильный треугольник. Эта задача может казаться слишком 
простой, но она иллюстрирует многие трудности создания программ 
распознавания образов.

     2. Моделирование видеообраза

     Из-за того, что имеющийся в распоряжении компьютер не 
связан с системой технического зрения и различные аппаратные 
средства системы технического зрения работают несколько по-дру-
гому, приходится моделировать визуальное изображение. Это можно 
делать, используя видеопамять дисплея компьютера. В IBM PC и 
аналогах каждой символьной позиции на экране соответствует байт 
в зарезервированной части оперативной памяти. Все что попадает в 
эту область памяти - отображается на экране. Имеет место также и 
обратная ситуация: все что отображается на экране - попадает в 
эту часть памяти. Чтобы моделировать изображение, получаемое от 
системы технического зрения, сначала очищается экран и затем 
отображаются контуры простых объектов. Это представляет высоко-
контрастное, плоское изображение. Затем программа просматривает 
видеопамять и пытается идентифицировать объекты. Как будет видно, 
что программы не имеют, никакого непосредственного знания о том, 
что помещено на экран. Видеоизображение моделируется в текстовом 
режиме. Это означает, что будет использоваться 24x80 позиций 
(байтовых) экрана для создания изображения. Каждый объект на 
экране изображается звездочками и пробелами. Если позиция содер-
жит звездочку, то компьютер принимает, что это часть контура; 
если позиция содержит пробел, то - к контуру не относится. Так 
создается высоко-контрастное черно-белое изображение. Программа 
просматривает изображение, используя BIOS, прерывание 10H, 
функцию 8, которая возвращает символ, находящийся в текущей 
позиции. Использование изображений в текстовом режиме позволяет 
пользователям без использования графических возможностей компью-
тера работать с представленными здесь программами распознавания 
образов.
     Прежде, чем начать изучение программ, обратите внимание на 
три функции, которые могут быть полезны. Начиная с некоторых вер-
сий трансляторов С, типа Microsoft C версия 4, не обеспечиваются
библиотечными подпрограммами перемещение курсора, очистка экрана, 
и различные вызовы BIOS. Эти функции необходимо составить самим. 
Эти функции показаны здесь; они используют int86() - универсаль-
ную подпрограмму прерывания.
     Все программы распознавания образов, которые представлены 
здесь, требуют поиска точек, составляющих контур. Поскольку про-
грамма не знает в каком месте экрана может находится объект, то
необходимо использовать функцию find_point() для поиска позиции,
содержащей звездочку. Каждый раз как вызывается find_point(), она 
начинает искать звездочки, стартуя с координаты startx, starty, 
и продвигается слева направо и верху вниз. Когда она находит  
звездочку, то возвращает ее позицию x и y. Теперь, когда извес-
тен способ моделирования видеоизображения и доступа к каждой 
позиции экрана, можно приступить к процессу распознавания.  

     3. Программа, распознающая по углу

     В сильно управляемой среде, правильно идентифицировать тре-
угольник или квадрат возможно, измеряя угол вершины. Ограничив-
шись только одним типом треугольников, равнобедренным, становит-
ся просто различать треугольник и квадрат: необходимо только про-
верить две точки в любой вершине. Если точки - под прямым углом, 
то объект должен быть квадратом. Если точки - под углом в 60 
градусов, то объект - треугольник.
     Один из самых простых способов распознавать по углам сос-
тоит в проверке местоположения точек смежных с вершиной. Напри-
мер, в любой вершине треугольника будет смежная звездочка на
диагонали. Аналогично идентифицируется квадрат, только звездочки
должны быть под прямым углом.
     Функции istriangle() и issquare() проверяют, соответственно,
является ли изображение треугольником или квадратом, когда уже
известно положение фигуры на экране.
     Для идентификации треугольника программа вызывает
istriangle() каждый раз как find_point() возвращает позицию зве-
здочки. Если треугольник обнаружен, то выполнение заканчивается;
если программа не находит треугольник, она делает попытку в дру-
гой позиции. В конечном счете треугольник обнаруживается.

===========================PART 1=========================================
/* search for a triangl and square      28.09.98
   Поиск треугольника и квадрата */
#include <stdio.h>

recognize()
{
   int x,y;

   x=y=0;
   while (find_point (x, y, &x, &y))
     {
       if (istriangle(x,y)) 
         {
	   gotoxy (0,0);
	   printf("triangle at %d %d ", x, y);
           break;
	 }
       x++;
     }
   x=y=0;
   while (find_point(x,y,&x,&y)) 
     {
       if (issquare(x,y)) 
        {
          gotoxy(0,1);
          printf("square at %d %d ",x,y);
          break;
	}
       x++;
     }
return;
}
#include <conio.h>

/* Recognition-by-Angles                     28.09.98
*/

main()
  {
     cls();
     position();
     recognize();
     getch();
     return;
  }
/* read the positions for the objects         28.09.98
   Ввод точек объектов */
#include <stdio.h>

void position()
{
   int x,y,a,b;

 gotoxy (0,0);
 do {
      printf("x y position of triangle:");
      scanf("%d%d", &x, &y);
    } while(outrange(x,y));

 do {
      printf("x y position of square:");
      scanf("%d%d", &a, &b);
    } while (outrange(x,y));
 cls();
 make_triangle (x,y);
 make_square (a,b);
}
/* return true if out-of-range coordinates     28.09.98
   Проверка лежит ли точка на линии */

 char outrange (x,y)
      int x,y;
{
   if(x<0 || x>79) return 1;
   if(y<0 || y>29) return 1;
   return 0;
}
/* draw a triangl at x,y               28.09.98
   Изображение треугольника в точке
  с координатами x,y */
#include <stdio.h>

make_triangle (x,y)
  int x,y;
{
   int t;

 for (t=0; t<5; t++) 
   {
     gotoxy(x-t,y+t);
     printf("*");
   }
 for (t=0; t<5; t++) 
   {
     gotoxy(x+t,y+t);
     printf("*");
   }

 gotoxy(x-5,y+5);
 printf("***********");
 return;
}
/* draw a square at x,y         28.09.98
   Изображение квадрата */
#include <stdio.h>

make_square (x,y)
    int x,y;
{
   int t;

   for (t=0; t<5; t++) 
     {
       gotoxy (x, y+t);
       printf("*");
     }
   for (t=0; t<5; t++)
     {
       gotoxy (x+10, y+t);
       printf ("*");
     }
   gotoxy(x,y);
   printf("***********");
   gotoxy(x,y+5);
   printf("***********");
   return;
}
/* check for a triangle            28.09.98
   Проверка треугольника */

int istriangle (x,y)
    int x,y;
{
   if (check_point(x+1,y+1) && check_point(x-1,y+1))
      return 1;

   return 0;
}
/* check for a square            28.09.98
   */

int issquare(x,y)
    int x,y;
{
   if (check_point(x+1,y) && check_point(x,y+1))
      return 1;

   return 0;
}/* put cursor at x,y                        28.09.98
   Установка курсора в позицию с координатами x,y */
#include <dos.h>

gotoxy (x,y)
     int x,y;
{
   union REGS regs;

   regs.h.ah=2;
   regs.h.dh=y;
   regs.h.dl=x;
   regs.h.bh=0;
   int86 (16, &regs, &regs);
   return;
}
/* returns the cursor loc of an '*' with the    28.09.98
   search beginning with startx and starty */
/* Возврат курсора.........
   поиск точки начала */

int find_point (startx, starty, x, y)
    int startx, starty, *x, *y;
{
   int a,b;

   a=startx; b=starty;
   do 
     {
      do 
        {
         if (check_point(a,b)) 
           {
             *x=a;  *y=b;
             return 1;
           }
         a++;
        } while (a<79);
      a=0; b++;
     } while (b<24);
   return 0;
}
/* clear the screen                28.09.98
   Очистка экрана */
#include <dos.h>

cls()
{
   union REGS regs;

   regs.h.ah=6;
   regs.h.al=0;
   regs.h.ch=0;
   regs.h.cl=0;
   regs.h.dh=24;
   regs.h.dl=79;
   regs.h.bh=7;
   int86 (16, &regs, &regs);
   return;
}
/* check to see if the point is an '*'      28.09.98
   by using BIOS int 10h,#8 */
/*Проверка является ли точка знаком '*'*/
#include <dos.h>

int check_point (a,b)
    int a,b;
{
  union REGS regs;

   gotoxy(a,b);
   regs.h.ah = 8;
   regs.h.bh = 0;
   int86 (16, &regs, &regs);
   if( regs.h.al=='*') return 1;
   return 0;
}
============================================================================

     4. Анализ программы распознавания по углу

     Запустите программу и введите координаты 10,10 для треу-
гольника и 55,12 для квадрата. На экране вы увидете то, что по-
казано на рисунке 9-8. Распознающие программы точно определяют
треугольник и квадрат.
     Сейчас следует обратиться к ранее приведенным вопросам,
которые касаются анализа программ распознавания. Позволяет ли 
метод правильно распознавать объекты, помещенные один сверху
другого? Что бы это узнать, запустите программу снова и введите
координаты 10,10 для обоих объектов. На экране появится картинка,
представленная на рисунке 9-9. Программа снова точно обнаружит
квадрат и треугольник.
     Влияет ли ориентация объекта на результат его распознавания?

  << Рисунок 9.8. Экран для программы распознавания по углу >>

К сожалению, способ, который заложен в программу, требует, чтобы
объекты находились в одной из нескольких строго определенных по-
зиций, они не могут вращаться произвольным образом. В данном
случае, не предусмотрена возможность вращения, так что это тре-
бование не является значительным недостатком, оно только препят-
ствует расширенному применению программы для решения других за-
дач. Однако, возможно разработать версию программы распознавания
по углу, позволяющую объектам вращаться.
     Влияет ли конкретный размер объекта на результат его рас-
познавания? Ответ - нет, потому что программа только определяет 
угол пересечения между двумя сторонами. Поэтому программа распо-
знавания по углу применима к объектам различных размеров.
     Насколько эффективна программа? Из-за своей простоты и огра-
ничений на ориентацию, программа достаточно эффективна.
     Может ли программа ошибаться? В рамках данных примеров
программа не будет делать ошибки. Но, если добавить другие типы
форм, то программа могла бы и делать ошибки. Например, программа
могла бы легко спутать прямоугольный треугольник с квадратом,
если ориентация треугольника такова, что программа начала провер-
ку с вершины противоположной гипотенузе.
     Этот анализ показывает, что программу можно применять только 
к сильно управляемым средам с минимальным числом разнообразия 
форм объектов.

 << Рисунок 9-9. Вариант перекрывания треугольника и
                 квадрата. >>


     5. Программа распознавания по ключевым точкам

     Поскольку прямоугольный треугольник может быть спутан про-
граммой распознавания по углу, то в этом разделе добавим прямо-
угольный треугольник к равнобедренному треугольнику и квадрату,
и создадим программу, идентифицирующую все три объекта.
     Один подход, при котором программа может идентифицировать
все объекты, требует, чтобы всегда они имели тот же самый размер.
Тогда исследуется только несколько ключевых точек. Ключевые
точки выбираются таким образом, что каждый их набор строго опре-
деляет только один объект. На рисунке 9-10 показаны три объекта,
которые должна распознавать программа, а также их ключевые точки.

  << Рисунок 9-10. Ключевые точки для треугольников и
                   квадрата >>

     Поскольку теперь два различных треугольника с различными
ключевыми точками, то простейшее решение - создать отдельную про-
грамму для распознавания каждого типа. Таким образом, в дополне-
ние к используемой issquare() для определения квадрата и
istriangle() - для равнобедренного треугольника, добавляется
isright() - для прямоугольного треугольника. Ниже представлены
новые версии этих программ.

===========================PART 2=========================================
/* search for a triangl and square      28.09.98
   Поиск треугольника и квадрата */
#include <stdio.h>

recognize_2()
{
   int x,y;

   x=y=0;
   while (find_point (x, y, &x, &y))
     {
       if (istriangle(x,y)) 
         {
	   gotoxy (0,0);
	   printf("triangle at %d %d ", x, y);
           break;
	 }
       x++;
     }
   x=y=0;
   while (find_point (x, y, &x, &y))
     {
       if (isright (x, y))
         {
           gotoxy (40,0);
           printf ("right triangle at %d %d", x, y); 
           break;
         }
       x++;
     }
   x=y=0;
   while (find_point(x,y,&x,&y)) 
     {
       if (issquare(x,y)) 
        {
          gotoxy(0,1);
          printf("square at %d %d ",x,y);
          break;
	}
       x++;
     }
return;
}
#include <conio.h>

/* Recognition by Key Points                     28.09.98
*/

main()
  {
     cls();
     position_2();
     recognize_2();
     getch();
     return;
  }
/* read the positions for the objects         28.09.98
   Ввод точек объектов */
#include <stdio.h>

void position_2()
{
   int x,y,a,b,i,j;

 gotoxy (0,0);
 do {
      printf("x y position of triangle:");
      scanf("%d%d", &x, &y);
    } while(outrange(x,y));
 do
   {
      printf ("x y position of right triangle: ");
      scanf ("%d%d", &i, &j);
   }  while (outrange(i,j));
 do {
      printf("x y position of square:");
      scanf("%d%d", &a, &b);
    } while (outrange(x,y));
 cls();
 make_triangle (x,y);
 make_square (a,b);
 make_right_triangle (i,j);
}
/* return true if out-of-range coordinates     28.09.98
   Проверка лежит ли точка на линии */

 char outrange (x,y)
      int x,y;
{
   if(x<0 || x>79) return 1;
   if(y<0 || y>29) return 1;
   return 0;
}
/* draw a right triangl at x,y               28.09.98
   Изображение ... треугольника в точке
  с координатами x,y */
#include <stdio.h>

void make_right_triangle(x,y)
     int x,y;
{
   int t;

   for (t=0; t<10; t++) 
      {
        gotoxy (x, y+t);
        printf ("*");
      }
   for (t=0; t<9; t++) 
      {
        gotoxy (x-t+9, y+t);
        printf("*");
      }
   gotoxy (x,y);
   printf("**********");
}
/* draw a triangl at x,y               28.09.98
   Изображение треугольника в точке
  с координатами x,y */
#include <stdio.h>

make_triangle (x,y)
  int x,y;
{
   int t;

 for (t=0; t<5; t++) 
   {
     gotoxy(x-t,y+t);
     printf("*");
   }
 for (t=0; t<5; t++) 
   {
     gotoxy(x+t,y+t);
     printf("*");
   }

 gotoxy(x-5,y+5);
 printf("***********");
 return;
}
/* draw a square at x,y         28.09.98
   Изображение квадрата */
#include <stdio.h>

make_square (x,y)
    int x,y;
{
   int t;

   for (t=0; t<5; t++) 
     {
       gotoxy (x, y+t);
       printf("*");
     }
   for (t=0; t<5; t++)
     {
       gotoxy (x+10, y+t);
       printf ("*");
     }
   gotoxy(x,y);
   printf("***********");
   gotoxy(x,y+5);
   printf("***********");
   return;
}
/* check for an isosceles triangle by key points  28.09.98
   Проверка .... */

int istriangle (x,y)
    int x,y;
{
   if (check_point (x+5,y+5))
    return 1;

   return 0;
}
/* check for a square by key points       28.09.98
   Проверка квадрата по ключевой точке */

int issquare(x,y)
    int x,y;
{
   if (check_point(x+10,y) && check_point (x,y+5) &&
       !check_point(x,y+6))  return 1;

   return 0;
}
/* check for a right triangle by key points    28.09.98
    Проверка ..... */

int isright (x,y)
     int x,y;
{
   if (check_point (x+9,y) && check_point (x,y+9))
      return 1;

   return 0;
}
/* returns the cursor loc of an '*' with the    28.09.98
   search beginning with startx and starty */
/* Возврат курсора.........
   поиск точки начала */

int find_point (startx, starty, x, y)
    int startx, starty, *x, *y;
{
   int a,b;

   a=startx; b=starty;
   do 
     {
      do 
        {
         if (check_point(a,b)) 
           {
             *x=a;  *y=b;
             return 1;
           }
         a++;
        } while (a<79);
      a=0; b++;
     } while (b<24);
   return 0;
}
/* check to see if the point is an '*'      28.09.98
   by using BIOS int 10h,#8 */
/*Проверка является ли точка знаком '*'*/
#include <dos.h>

int check_point (a,b)
    int a,b;
{
  union REGS regs;

   gotoxy(a,b);
   regs.h.ah = 8;
   regs.h.bh = 0;
   int86 (16, &regs, &regs);
   if( regs.h.al=='*') return 1;
   return 0;
}
====================================================================


     6. Анализ программы распознавания по ключевым точкам

     Запустите программу, и введите следующие координаты:
Равнобедренный треугольник 10,4
Прямоугольный треугольник 55,11
Квадрат 30,12
На экране дисплея, появится картинка как показанная на рисунке
9-11. Очевидно, что метод распознавания по ключевым точкам рабо-
тает только для этой ограниченной ситуации.

  << Рисунок 9-11. Иллюстрация программы распознавания по
                   ключевым точкам >>

  << Рисунок 9-12. Изображение трех объектов при стартовой
                   точке 10,10 >>

     Чтобы понять ограничения программы, необходимо ответить на
все те же пять вопросов. Может ли программа правильно распознать
объекты, находящиеся один сверху другого? Что бы это выяснять,
запустим программу и поместим все объекты в точку 10,10. Ответ -
нет: как показано на рисунке 9-12, программа теперь думает, что
там только один квадрат и один треугольник.
     Влияет ли ориентация объектов на результат распознавания?
Рисунок 9-12 показывает, что программа находит все объекты, но
она думает, что квадрат находится в точке 10,14, а не в 10,10!
Это результат перекрывания объектов, путающих схему распознава-
ния.
     Влияет ли точный размер объекта на результат распознавания?
Ответ - да. Каждый объект должен иметь точно установленный раз-
мер при использовании программы распознавания по ключевым точкам,
так как точки должны находиться на фиксированных расстояниях.
     Насколько эффективна программа? Программа абсолютно эффек-
тивна, потому что она исследует только несколько точек для опре-
деления объекта, она почти столь же эффективна, как и программа
распознавания по углу.
     Может ли программа легко ошибаться? Если экспериментировать
с программой, то можно определить, что можно ее заставлить думать,
что там представлены три треугольника! Это случается, если упоря-
дочить позиции треугольников и квадрата таким образом, что будут
отдельные точки, которые появляются в программе, которые сформи-
руют треугольник.
     Этот подход дает возможность распознавать большее разно-
образие треугольников, но требуется еще более ограниченная среда,
при распознавании по углу, и довольно легко ошибиться.


     7. Распознаватель Дельта-Д

     Последний метод распознавания, рассматриваемый в этой главе,  
основан на подсчете количества изменении направления. Например, 
начиная с любой точки треугольника осуществляется проход по всем
его сторонам с возвратом в отправную точку, направление при этом
изменяется три раза. При проходе по сторонам квадрата направле-
ние меняется четыре раза. Количество изменений направления соот-
ветствует количеству вершин формы. ( Круг можно воспринимать как 
форму с бесконечным числом изменений направления или как имеющую 
нулевое изменение). Каждый раз как встречается вершина происходит 
изменение направления. В математике такие изменения часто обозна-
чаются как дельта. Поскольку данная программа, представленная 
здесь, основана на изменении направления, то этот метод иногда  
называют распознавателем Дельта-Д, где D - происходит от слова 
direction (направление).
     Для того что бы распознаватель Дельта-Д мог функционировать, 
он должен уметь проходить по контуру объекта, то есть программа 
должна быть способной проходить по прямой линии до ее пересечения 
с другой прямой линией. В точке пересечения программа должна 
правильно найти следующую прямую линию и пойти по ней. Существу-
ет много способов выполнить распознаватель Дельта-Д. Решение, 
представленное здесь требует использования базы данных, назван-
ной oldp, в которой хранится список всех точек, используемых для 
двух целей: 1) программа должна знать, когда она вернулась в 
стартовую точку, то есть проследовала весь контур объекта; 
2) должна быть предотвращена возможность того, что программа
пошла по своему хвосту. Функция assert_oldp() сохраняет в базе
местоположение точек; функция find() проверяет наличие в базе
конкретной точки.
     Основными функциями распознавателя Дельта-Д являются 
follow() и find_direction(). Зададим начальную точку. Функция
follow() вызывает функцию find_direction() для определения зна-
чений приращений incx и incy. Затем происходит движение вдоль 
линии, определяемой этими приращениями. Если следующая позиция 
не содержит звездочки, которая показывает поворот, то follow()
вызывает find_direction(), чтобы определить новый набор прира-
щений. Процесс заканчивается, когда программа снова вернется в 
стартовую точку. Функция find_direction() просматривает все
смежные позиции, чтобы найти звездочку. Функция find() возвраща-
ет "истина", если точка уже находится в базе oldp и "ложь" -
если ее там нет. Поэтому в базе нет точек, которые были уже прой-
дены. Этот шаг предотвращает продвижение по уже пройденному пути,
то есть исключает зацикливание. 
     Функция istriangle() и issquare() изменяются. В отличие от
распознавания по ключевым точкам Дельта-Д распознаватель требует
только одну функцию для распознавания треугольгика, так как все 
треугольники имеют три стороны. Точный размер и расположение -
не имеет значения.
     Если объект - треугольник, то направление изменится дважды
(не три раза, так как эта версия функции istriangle() не рассмат-
ривает изменение начального направления). Следовательно, если
follow() возвращает 2, то это показывает, что найден треуголь-
ник. Аналогично, если follow() возвращает 3 - распознан квадрат.

===========================PART 3=========================================
#define MAX 200

struct oldpoints {
   int x,y;
};

/* search for a triangl and square      28.09.98
   Поиск треугольника и квадрата */
#include <stdio.h>

recognize_3()
{
   int x,y,t;

for (t=0; t<2; )
 { x=y=0;
   while (find_point (x, y, &x, &y))
     {
       if (istriangle(x,y)) 
         {
	   gotoxy (t*40,0); t++;
	   printf("triangle at %d %d ", x, y);
           break;
	 }
       x++;
     }
 }
   clear_db();
   x=y=0;
   while (find_point(x,y,&x,&y)) 
     {
       if (issquare(x,y)) 
        {
          gotoxy(0,1);
          printf("square at %d %d ",x,y);
          break;
	}
       x++;
     }
return;
}
#include <conio.h>
#include "recogn3.h"

/* Delta-D Recognizer                         28.09.98
*/
	     int  pos;   /* indexes into database */
struct oldpoints  oldp[MAX];

main()
  {
     cls();
     clear_db();
     position_2();
     recognize_3();
     getch();
     return;
  }
/* read the positions for the objects         28.09.98
   Ввод точек объектов */
#include <stdio.h>

void position_2()
{
   int x,y,a,b,i,j;

 gotoxy (0,0);
 do {
      printf("x y position of triangle:");
      scanf("%d%d", &x, &y);
    } while(outrange(x,y));
 do
   {
      printf ("x y position of right triangle: ");
      scanf ("%d%d", &i, &j);
   }  while (outrange(i,j));
 do {
      printf("x y position of square:");
      scanf("%d%d", &a, &b);
    } while (outrange(x,y));
 cls();
 make_triangle (x,y);
 make_square (a,b);
 make_right_triangle (i,j);
}
/* return true if out-of-range coordinates     28.09.98
   Проверка лежит ли точка на линии */

 char outrange (x,y)
      int x,y;
{
   if(x<0 || x>79) return 1;
   if(y<0 || y>29) return 1;
   return 0;
}
/* draw a right triangl at x,y               28.09.98
   Изображение ... треугольника в точке
  с координатами x,y */
#include <stdio.h>

void make_right_triangle(x,y)
     int x,y;
{
   int t;

   for (t=0; t<10; t++) 
      {
        gotoxy (x, y+t);
        printf ("*");
      }
   for (t=0; t<9; t++) 
      {
        gotoxy (x-t+9, y+t);
        printf("*");
      }
   gotoxy (x,y);
   printf("**********");
}
/* draw a triangl at x,y               28.09.98
   Изображение треугольника в точке
  с координатами x,y */
#include <stdio.h>

make_triangle (x,y)
  int x,y;
{
   int t;

 for (t=0; t<5; t++) 
   {
     gotoxy(x-t,y+t);
     printf("*");
   }
 for (t=0; t<5; t++) 
   {
     gotoxy(x+t,y+t);
     printf("*");
   }

 gotoxy(x-5,y+5);
 printf("***********");
 return;
}
/* draw a square at x,y         28.09.98
   Изображение квадрата */
#include <stdio.h>

make_square (x,y)
    int x,y;
{
   int t;

   for (t=0; t<5; t++) 
     {
       gotoxy (x, y+t);
       printf("*");
     }
   for (t=0; t<5; t++)
     {
       gotoxy (x+10, y+t);
       printf ("*");
     }
   gotoxy(x,y);
   printf("***********");
   gotoxy(x,y+5);
   printf("***********");
   return;
}
/* check for an isosceles triangle by key points  28.09.98
   Проверка .... */

int istriangle (x,y)
    int x,y;
{
   if (follow (x,y)==2) return 1;

   return 0;
}
/* check for a square by key points       28.09.98
   Проверка квадрата по ключевой точке */

int issquare(x,y)
    int x,y;
{
   if (follow(x,y)==3)  return 1;

   return 0;
}
/* follow a shape and return number of turns     28.09.98
*/

int follow(x,y)
    int x,y;
{
   int  incx, incy,
        startx, starty, count;

   startx=x;  starty=y;
   count=0;
   assert_oldp (x,y);
   if (!find_direction (x, y, &incx, &incy)) return 0;
   do
     {
       while (check_point (x+incx, y+incy))
         {
           x = incx + x;
           y = incy + y;
           assert_oldp (x,y);
         }
       if (x == startx && y == starty) return count;
       count++;
       if (!find_direction (x, y, &incx, &incy))  return 0;
     } while(1);
}

/* find a new line to follow               28.09.98
   Поиск новой линии для слежения
   */

int find_direction (x,y,incx,incy)
    int  x,y,*incx,*incy;
{
   register int a,b;

   for (a=-1; a<2; a++)
     for (b=-1; b<2; b++)
       if (check_point (x+a,y+b) && !find (x+a,y+b))
         {
           *incx=a; *incy=b;
           return 1;
         }
   return 0;
}

/*                                        20.09.98
*/
#include "recogn3.h"

int find(x,y)
    int x,y;
{
	   register int  t;
	     extern int  pos;
extern struct oldpoints  oldp[];

   for (t=0; t<pos; t++)
      if( oldp[t].x==x && oldp[t].y==y) return 1;

   return 0;
}
/* returns the cursor loc of an '*' with the    28.09.98
   search beginning with startx and starty */
/* Возврат курсора.........
   поиск точки начала */

int find_point (startx, starty, x, y)
    int startx, starty, *x, *y;
{
   int a,b;

   a=startx; b=starty;
   do 
     {
      do 
        {
         if (check_point(a,b)) 
           {
             *x=a;  *y=b;
             return 1;
           }
         a++;
        } while (a<79);
      a=0; b++;
     } while (b<24);
   return 0;
}
/* clear the screen                28.09.98
   Очистка экрана */
#include <dos.h>

cls()
{
   union REGS regs;

   regs.h.ah=6;
   regs.h.al=0;
   regs.h.ch=0;
   regs.h.cl=0;
   regs.h.dh=24;
   regs.h.dl=79;
   regs.h.bh=7;
   int86 (16, &regs, &regs);
   return;
}
/*                                     28.09.98
*/
#include "recogn3.h"

void clear_db()
{
	    register int  t;
	      extern int  pos;
 extern struct oldpoints  oldp[];

   for (t=0; t<MAX; t++)   oldp[t].x = oldp[t].y= 0;
}

/* check to see if the point is an '*'      28.09.98
   by using BIOS int 10h,#8 */
/*Проверка является ли точка знаком '*'*/
#include <dos.h>

int check_point (a,b)
    int a,b;
{
  union REGS regs;

   gotoxy(a,b);
   regs.h.ah = 8;
   regs.h.bh = 0;
   int86 (16, &regs, &regs);
   if( regs.h.al=='*') return 1;
   return 0;
}
/*                                         28.09.98
*/
#include "recogn3.h"

void assert_oldp (x,y)
      int  x,y;
{
	       extern int  pos;
  extern struct oldpoints  oldp[];

  if (pos==MAX)
    {
      printf("point database full\n");
      return ;
    }
  if (find(x,y)) return; /* already in db */
  oldp[pos].x=x;
  oldp[pos].y=y;
  pos++;
}
=========================================================================


  << Рисунок 9-13. Изображение для программы Дельта-Д

     8. Анализ программы распознавателя Дельта-Д 

     Запустим программу и введем следующие координаты:        
Равнобедренный треугольник 10,4 
Прямоугольный треугольник 55,11 
Квадрат 30,12
На экране будет картинка, подобная показанной на рисунке 9-13. 
Ясно, метод распознавания Дельта-Д работает в ограниченном коли-
честве ситуаций.
     Чтобы понять слабости программы, необходимо ответить на пять 
вопросов-критериев. Может ли программа правильно распознать 
объекты, когда один находится сверху другого? Этот вопрос выяв-
ляет самое слабое место распознавания Дельта-Д: в этом случае он 
полностью разваливается. Чтобы в этом убедиться запустим прог-

  << Рисунок 9-14. Изображение трех объектов в точке 10,10 >>

рамму с координатами для всех объектов - 10,10. Результат пока-
зан на рисунке 9-14: программа запутывается при поиске любого 
треугольника, и совершенно случайно идентифицирует квадрат. Она 
не может различать треугольники, потому что находит слишком мно-
го изменений направления, в результате чего следует в направле-
нии многих различных линий.
     Влияет ли ориентация объектов на результат распознавания? 
Это одно из самых лучших свойств программы: она функционирует 
правильно независимо от того, в какой позиции находятся объекты. 
Эта характеристика делает распознаватель Дельта-Д привлекатель-
ным во многих реальных ситуациях.  
     Влияет ли точный размер каждого объекта на результат распо-
знавания? Нет. Это другой хороший момент в подходе Дельта-Д, то 
можно использовать программу для распознавания класса объектов.
     Насколько эффективна программа? Потому что распознаватель
Дельта-Д намного более общий, чем предыдущие две программы, то 
она не функционирует так же эффективно. Но показатель эффектив-
ности здесь менее важен, чем надежность правильного распознава-
ния.
     Может ли программа легко ошибаться (запутываться)? 
Как было показано, распознаватель Дельта-Д может легко запутать-
ся, если объекты наложены друг на друга, но ошибки не будет для
непересекающихся объектов.       
     В конечном счете, метод распознавания Дельты-Д обеспечивает 
самую большую общность из этих трех программ. Комбинация различ-
ных подходов может позволить использовать систему для работы в 
реальных ситуациях.    

